const fs = require("fs");
const path = require("path");

var version = require("../package.json").libgit2.version;
var descriptor = require("./descriptor.json");
var libgit2 = require("./v" + version + ".json");

// This file was generated by @nkallen.
var legacy = require("./nkallen.json");

// Extracted types.
var typeMap = require("./types.json");

// Structs or new types between v0.18 and v0.20.
typeMap.__proto__ = {
  "git_filter_mode_t": { cpp: "Number", js: "Number" },
  "const git_blame_hunk *": { cpp: "GitBlameHunk", js: "BlameHunk" },
  "git_blame_hunk *": { cpp: "GitBlameHunk", js: "BlameHunk" },
  "git_filter *": { cpp: "GitFilter", js: "Filter" },
  "const git_status_entry *": { cpp: "StatusEntry", js: "StatusEntry" },
  "const git_index_name_entry *": {
    cpp: "IndexNameEntry", js: "IndexNameEntry" },
  "git_time": { cpp: "GitTime", js: "Time", },
  "git_vector": { cpp: "Array", js: "Array", },

  // unsure
  "uint16_t": { cpp: "Integer", js: "Number" },
  "git_blame_options": { cpp: "Integer", js: "Number" },
  "git_blame_options *": { cpp: "Integer", js: "Number" },
  "git_buf *": { cpp: "Buf", js: "Buf" },
  "git_branch_iterator *": { cpp: "BranchIterator", js: "Iterator" },
  "git_branch_iterator **": { cpp: "BranchIterator", js: "Iterator" },
  "git_branch_t *": { cpp: "GitBranch", js: "Branch" }
};

var files = [];

function titleCase(str) {
  return str.split(/_|\//).map(function(val, index) {
    if (val.length) {
      return val[0].toUpperCase() + val.slice(1);
    }

    return val;
  }).join("");
}

function camelCase(str) {
  return str.split(/_|\//).map(function(val, index) {
    if (val.length) {
      return index >= 1 ? val[0].toUpperCase() + val.slice(1) : val;
    }

    return val;
  }).join("");
}

Object.keys(descriptor).forEach(function(fileName, index) {
  var file = descriptor[fileName];

  // Constants.
  file.filename = fileName + ".h";
  file.ignore = typeof file.ignore == "boolean" ? file.ignore : true;
  file.cppClassName = "Git" + titleCase(fileName);
  file.jsClassName = file.cppClassName;

  // Adjust to find the real the index.
  libgit2.files.some(function(currentFile, _index) {
    if (currentFile.file === file.filename) {
      index = _index;
      return true;
    }
  });

  var cFile = libgit2.files[index];

  if (file.cType === undefined) {
    if (cFile.functions.length) {
      file.cType = cFile.functions[0].split("_").slice(0, 2).join("_");
    }
  }

  if (file.cType) {
    file.freeFunctionName = "git_" + fileName + "_free";
  }

  if ((!cFile || !cFile.functions) && !file.isStruct) {
    return;
  }

  // TODO Obsolete this.
  if (file.isStruct) {
    // No functions.
    cFile = file;
    cFile.functions = [];
  }

  // Doesn't actually exist.
  if (cFile.functions.indexOf(file.freeFunctionName) === -1) {
    delete file.freeFunctionName;
  }


  var legacyFile = legacy.filter(function(currentFile) {
    return currentFile.filename === file.filename;
  })[0] || {};

  if (file.jsClassName.indexOf("Git") === 0) {
    file.jsClassName = file.jsClassName.slice(3);
  }

  var uniqueTypes = [];

  var addType = function(arg) {
    if (!arg.type) { return; }
    if (arg.type.indexOf("git") === 0) {
      var val = arg.type.split(" ")[0].slice(4);

      if (uniqueTypes.indexOf(val) === -1 && descriptor[val]) {
        uniqueTypes.push(val);
      }
    }
  };

  cFile.functions.forEach(function(functionName) {
    var funcDescriptor = libgit2.functions[functionName];

    var args = funcDescriptor.args || [];

    args.forEach(addType);
    addType(funcDescriptor.return.type);
  });

  var deps = file.dependencies;

  file.dependencies = uniqueTypes.map(function(file) {
    return "../include/" + file + ".h"; 
  });

  if (deps) {
    file.dependencies.push.apply(file.dependencies, deps);
  }

  // Add to the type's list if it's new.
  typeMap["const " + "git_" + fileName + " *"] =
  typeMap["const " + "git_" + fileName + " **"] =
  typeMap["git_" + fileName + " *"] =
  typeMap["git_" + fileName + " **"] =
  typeMap["git_" + fileName] = {
    cpp: file.cppClassName,
    js: file.jsClassName 
  };

  var fields = file.fields || [];

  // Decorate fields.
  file.fields = fields.map(function(field) {
    field.cppFunctionName = titleCase(field.name);
    field.jsFunctionName = camelCase(field.name);
    field.cppClassName = typeMap[field.cType].cpp;
    field.jsClassName = typeMap[field.cType].js;

    return field;
  });

  // Used to identify a missing function descriptor later on.
  var ident = {};

  //Object.keys(file.functions || {}).forEach(function(functionName) {
  //  if (cFile.functions.indexOf(functionName) === -1 && functionName) {
  //    cFile.functions.push(functionName);
  //  }
  //});

  file.functions = cFile.functions.map(function(functionName, index) {
    var funcDescriptor = libgit2.functions[functionName];
    var descriptor = legacyFile.functions ? legacyFile.functions[index] || {} : {};
    var cType = file.cType || "git";

    // From the hand maintained file.
    var functionDescriptor = file.functions ? file.functions[functionName] || ident : ident;

    if (!functionName || !funcDescriptor) { return; }

    descriptor.cFunctionName = functionName;
    descriptor.ignore = functionDescriptor === ident;

    if (typeof functionDescriptor.ignore === "boolean") {
      descriptor.ignore = functionDescriptor.ignore;
    }

    var trimmedName = functionName.slice(cType.length + 1);

    if (trimmedName === "new") {
      trimmedName = "new2";
    }

    descriptor.cppFunctionName = functionDescriptor.cppFunctionName || titleCase(trimmedName);
    descriptor.jsFunctionName = functionDescriptor.jsFunctionName || camelCase(trimmedName);

    // Add to the type's list if it's new.
    typeMap["const " + descriptor.cFunctionName + " *"] =
    typeMap[descriptor.cFunctionName + " *"] =
    typeMap[descriptor.cFunctionName] = {
      cpp: descriptor.cppFunctionName,
      js: descriptor.jsFunctionName 
    };

    var retVal = descriptor.return = functionDescriptor.return || {};
    retVal.cType = funcDescriptor.return.type;

    var type = typeMap[retVal.cType];

    if (!retVal.cppClassName) {
      retVal.cppClassName = type.cpp;
    }

    if (!retVal.jsClassName) {
      retVal.jsClassName = type.js;
    }

    var args = descriptor.args || [];
    var typeDescriptor = args.length ? args[0].type || "" : "";

    var isCtor = Boolean(functionDescriptor.isConstructorMethod);

    descriptor.isConstructorMethod = isCtor;

    // Set the prototype method argument.
    descriptor.isPrototypeMethod = !descriptor.isConstructorMethod;

    var hasReturn = false;

    descriptor.args = funcDescriptor.args.map(function(arg, index) {
      var manualArgs = functionDescriptor.args || [];

      var isSelf = function() {
        if (manualArgs[index] && typeof manualArgs[index].isSelf === "boolean") {
          return manualArgs[index].isSelf;
        }

        if (index === 0) { return false; }
        return file.jsClassName === typeMap[arg.type].js;
      };

      var isReturn = function() {
        if (manualArgs[index] && typeof manualArgs[index].isReturn === "boolean") {
          return manualArgs[index].isReturn;
        }

        if (index > 0) { return false; }
        if (arg.name === "out" || arg.name.slice(-4) === "_out") {
          hasReturn = true;
          return true;
        }

        if ((arg.type || "").replace(/[* ]/g, "") === file.cType) {
          hasReturn = true;
          return true;
        }

        return false;
      };

      if (typeMap[arg.type]) {
        return {
          name: arg.name,
          cType: arg.type,
          cppClassName: typeMap[arg.type].cpp,
          jsClassName: typeMap[arg.type].js,
          comment: arg.comment,
          isReturn: isReturn() || false,
          isSelf: isSelf() || false,
          shouldAlloc: manualArgs[index] ? manualArgs[index].shouldAlloc || false : false
        };
      }

      return {};
    });

    // By default all methods are synchronous.
    descriptor.isAsync = false;

    // Determine if retVal isErrorCode.
    if (retVal.cType === "int" && hasReturn) {
      retVal.isErrorCode = true;
      descriptor.isAsync = true;
    }

    if (typeof functionDescriptor.isAsync === "boolean") {
      descriptor.isAsync = functionDescriptor.isAsync;
    }

    return descriptor;
  });

  files.push(file);
});

fs.writeFileSync(path.join(__dirname, "types.json"), 
  JSON.stringify(typeMap, null, 2));

fs.writeFileSync(path.join(__dirname, "idefs.json"), 
  JSON.stringify(files, null, 2));
